// Copyright (c) Munition AutoPatcher contributors. Licensed under the MIT License.

namespace IntegrationTests.Infrastructure.Models;

/// <summary>
/// Bundle of artifacts produced by a single scenario run, capturing inputs, outputs, and diagnostics.
/// </summary>
public sealed class ScenarioRunArtifact
{
    /// <summary>
    /// Foreign key to E2EScenarioDefinition.Id.
    /// </summary>
    public required string ScenarioId { get; init; }

    /// <summary>
    /// Unique identifier for this run instance.
    /// </summary>
    public string RunId { get; init; } = Guid.NewGuid().ToString("N")[..8];

    /// <summary>
    /// Start time of the run (UTC).
    /// </summary>
    public required DateTime ExecutionTimestampUtc { get; init; }

    /// <summary>
    /// Total execution duration.
    /// </summary>
    public TimeSpan Duration { get; set; }

    /// <summary>
    /// Physical path to the synthetic Data directory used for Mutagen.
    /// </summary>
    public required string TempDataPath { get; init; }

    /// <summary>
    /// Physical path where MapperViewModel emitted the ESP.
    /// </summary>
    public required string TempOutputPath { get; init; }

    /// <summary>
    /// Full path to the produced ESP (should match TempOutputPath/ExpectedEspName).
    /// </summary>
    public string? GeneratedEspPath { get; set; }

    /// <summary>
    /// Captures counts, warnings, and errors from validation.
    /// </summary>
    public ValidationResult? ValidationResult { get; set; }

    /// <summary>
    /// Logger output and DiagnosticWriter files aggregated.
    /// </summary>
    public DiagnosticBundle Diagnostics { get; init; } = new();

    /// <summary>
    /// Location zipped/uploaded by CI for download.
    /// </summary>
    public string? ArtifactsRoot { get; set; }

    /// <summary>
    /// Current state of the run.
    /// </summary>
    public RunState State { get; set; } = RunState.Initialized;

    /// <summary>
    /// Error message if the run failed.
    /// </summary>
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Whether the overall run succeeded (ESP generated and validation passed).
    /// </summary>
    public bool IsSuccess => State == RunState.Published || 
                             (State >= RunState.EspValidated && ValidationResult?.IsValid == true);
}

/// <summary>
/// State transitions for a scenario run.
/// </summary>
public enum RunState
{
    /// <summary>Directories created, scenario metadata logged.</summary>
    Initialized = 0,

    /// <summary>MapperViewModel commands finished (success/fail recorded).</summary>
    ViewModelExecuted = 1,

    /// <summary>ValidationResult computed.</summary>
    EspValidated = 2,

    /// <summary>Artifacts zipped and uploaded (CI step).</summary>
    Published = 3,

    /// <summary>Run failed with an error.</summary>
    Failed = -1
}

/// <summary>
/// Aggregates logger output and DiagnosticWriter files for a scenario run.
/// </summary>
public sealed class DiagnosticBundle
{
    /// <summary>
    /// xUnit ITestOutputHelper logs or file-based log paths.
    /// </summary>
    public List<string> LogFilePaths { get; init; } = [];

    /// <summary>
    /// Paths to CSV/JSON files generated by IDiagnosticWriter.
    /// </summary>
    public List<string> DiagnosticWriterOutputs { get; init; } = [];

    /// <summary>
    /// Paths to diff reports from EspFileValidator.
    /// </summary>
    public List<string> ValidationReports { get; init; } = [];

    /// <summary>
    /// CI environment upload root (GitHub Actions artifacts, etc.).
    /// </summary>
    public string? CIArtifactRoot { get; set; }

    /// <summary>
    /// ViewModel status messages captured during execution.
    /// </summary>
    public List<string> StatusMessages { get; init; } = [];

    /// <summary>
    /// Adds a log file path to the bundle.
    /// </summary>
    public void AddLogFile(string path)
    {
        if (!string.IsNullOrWhiteSpace(path))
            LogFilePaths.Add(path);
    }

    /// <summary>
    /// Adds a diagnostic writer output path to the bundle.
    /// </summary>
    public void AddDiagnosticOutput(string path)
    {
        if (!string.IsNullOrWhiteSpace(path))
            DiagnosticWriterOutputs.Add(path);
    }

    /// <summary>
    /// Adds a validation report path to the bundle.
    /// </summary>
    public void AddValidationReport(string path)
    {
        if (!string.IsNullOrWhiteSpace(path))
            ValidationReports.Add(path);
    }
}

/// <summary>
/// Result of ESP validation containing structural counts, warnings, and errors.
/// </summary>
public sealed class ValidationResult
{
    /// <summary>
    /// Computed flag (no errors).
    /// </summary>
    public bool IsValid => Errors.Count == 0;

    /// <summary>
    /// Structural or binary validation failures.
    /// </summary>
    public List<string> Errors { get; init; } = [];

    /// <summary>
    /// Non-blocking findings (e.g., small file).
    /// </summary>
    public List<string> Warnings { get; init; } = [];

    /// <summary>
    /// Total count of WEAP/AMMO/COBJ records touched.
    /// </summary>
    public int RecordCount { get; set; }

    /// <summary>
    /// Count of WEAP records in the ESP.
    /// </summary>
    public int WeaponCount { get; set; }

    /// <summary>
    /// Count of AMMO records in the ESP.
    /// </summary>
    public int AmmoCount { get; set; }

    /// <summary>
    /// Count of COBJ records in the ESP.
    /// </summary>
    public int CobjCount { get; set; }

    /// <summary>
    /// Size of the generated ESP in bytes.
    /// </summary>
    public long FileSizeBytes { get; set; }

    /// <summary>
    /// Whether the parsed header passed deterministic checks.
    /// </summary>
    public bool HasValidHeader { get; set; }

    /// <summary>
    /// Adds an error to the result.
    /// </summary>
    public void AddError(string error)
    {
        if (!string.IsNullOrWhiteSpace(error))
            Errors.Add(error);
    }

    /// <summary>
    /// Adds a warning to the result.
    /// </summary>
    public void AddWarning(string warning)
    {
        if (!string.IsNullOrWhiteSpace(warning))
            Warnings.Add(warning);
    }

    /// <summary>
    /// Creates a successful validation result with the given counts.
    /// </summary>
    public static ValidationResult Success(int weaponCount, int ammoCount, int cobjCount, long fileSize) =>
        new()
        {
            WeaponCount = weaponCount,
            AmmoCount = ammoCount,
            CobjCount = cobjCount,
            RecordCount = weaponCount + ammoCount + cobjCount,
            FileSizeBytes = fileSize,
            HasValidHeader = true
        };

    /// <summary>
    /// Creates a failed validation result with the given error.
    /// </summary>
    public static ValidationResult Failure(string error) =>
        new() { Errors = [error] };
}

/// <summary>
/// Manifest for serializing scenario run information to JSON.
/// </summary>
public sealed class RunManifest
{
    /// <summary>
    /// Scenario identifier.
    /// </summary>
    public required string ScenarioId { get; init; }

    /// <summary>
    /// Run identifier.
    /// </summary>
    public required string RunId { get; init; }

    /// <summary>
    /// Execution timestamp in ISO 8601 format.
    /// </summary>
    public required string ExecutionTimestamp { get; init; }

    /// <summary>
    /// Duration in seconds.
    /// </summary>
    public double DurationSeconds { get; init; }

    /// <summary>
    /// Whether the run succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Error message if failed.
    /// </summary>
    public string? ErrorMessage { get; init; }

    /// <summary>
    /// Paths to generated artifacts.
    /// </summary>
    public List<string> ArtifactPaths { get; init; } = [];

    /// <summary>
    /// Validation summary.
    /// </summary>
    public ValidationSummary? Validation { get; init; }

    /// <summary>
    /// Creates a manifest from a ScenarioRunArtifact.
    /// </summary>
    public static RunManifest FromArtifact(ScenarioRunArtifact artifact) =>
        new()
        {
            ScenarioId = artifact.ScenarioId,
            RunId = artifact.RunId,
            ExecutionTimestamp = artifact.ExecutionTimestampUtc.ToString("O"),
            DurationSeconds = artifact.Duration.TotalSeconds,
            Success = artifact.IsSuccess,
            ErrorMessage = artifact.ErrorMessage,
            ArtifactPaths = 
            [
                ..artifact.Diagnostics.LogFilePaths,
                ..artifact.Diagnostics.DiagnosticWriterOutputs,
                ..artifact.Diagnostics.ValidationReports
            ],
            Validation = artifact.ValidationResult != null
                ? new ValidationSummary
                {
                    IsValid = artifact.ValidationResult.IsValid,
                    WeaponCount = artifact.ValidationResult.WeaponCount,
                    AmmoCount = artifact.ValidationResult.AmmoCount,
                    CobjCount = artifact.ValidationResult.CobjCount,
                    FileSizeBytes = artifact.ValidationResult.FileSizeBytes,
                    ErrorCount = artifact.ValidationResult.Errors.Count,
                    WarningCount = artifact.ValidationResult.Warnings.Count
                }
                : null
        };
}

/// <summary>
/// Summary of validation results for manifest serialization.
/// </summary>
public sealed class ValidationSummary
{
    public bool IsValid { get; init; }
    public int WeaponCount { get; init; }
    public int AmmoCount { get; init; }
    public int CobjCount { get; init; }
    public long FileSizeBytes { get; init; }
    public int ErrorCount { get; init; }
    public int WarningCount { get; init; }
}
