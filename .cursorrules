# Cursor Rules for Munition AutoPatcher vC

You are an expert C# WPF developer working on the Munition AutoPatcher vC project.
Your goal is to write clean, maintainable, and robust code that adheres to the project's strict architectural guidelines.

## Reference Repositories (CRITICAL)

⚠️ **IMPORTANT: This project targets FALLOUT 4, NOT Skyrim**

When using MCP tools to query Mutagen documentation:

### Primary References

- **Mutagen.Bethesda.Fallout4**: https://github.com/Mutagen-Modding/Mutagen
  - Specifically reference **Fallout 4** implementations, NOT Skyrim
  - Key files to reference:
    - `Mutagen.Bethesda.Fallout4/Records/Major Records/Weapon.xml`
    - `Mutagen.Bethesda.Fallout4/Records/Major Records/ObjectModification.xml`
    - `Mutagen.Bethesda.Fallout4/Records/Major Records/ConstructibleObject.xml`

### Context Guidelines for AI

1. **Game Specification**: Always specify "Fallout 4" when querying Mutagen APIs
   - ❌ BAD: `@github Show me Weapon record structure`
   - ✅ GOOD: `@github Show me Fallout 4 Weapon record structure in Mutagen.Bethesda.Fallout4`

2. **Version Pinning**: This project uses Mutagen v0.51.5
   - Reference tag: `0.51.5` when fetching implementation details

3. **Game-Specific Records**:
   - WEAP (Weapon)
   - OMOD (Object Modification)
   - COBJ (Constructible Object)
   - AMMO (Ammunition)
   - FLST (Form List)

### Example MCP Queries

@github Fetch Mutagen.Bethesda.Fallout4/Records/Major Records/Weapon.xml from Mutagen-Modding/Mutagen

## Core Principles

1.  **MVVM Architecture**:
    -   Strictly separate View (XAML), ViewModel, and Model/Service.
    -   **Views**: No business logic in code-behind. Only UI logic.
    -   **ViewModels**: Handle state, commands, and presentation logic. Use `RelayCommand` or `AsyncRelayCommand`.
    -   **Services**: Encapsulate business logic. UI-agnostic.

2.  **Dependency Injection**:
    -   Use Constructor Injection for ALL dependencies.
    -   Never use `new` for services or ViewModels (except in factories or bootstrapper).
    -   Avoid Service Locator pattern.

3.  **Mutagen Integration (CRITICAL)**:
    -   **NEVER** call Mutagen.Bethesda APIs directly from ViewModels or Views.
    -   **ALWAYS** use `IMutagenAccessor` or specific strategy interfaces to interact with Mutagen.
    -   **NO** Reflection or `dynamic` unless explicitly requested and encapsulated in an Accessor/Detector.
    -   **NO** Version pinning. Use capability detection if API differences exist.

4.  **Async & Threading**:
    -   Use `async`/`await` for all I/O and heavy operations.
    -   **NEVER** use `.Result` or `.Wait()`.
    -   Use `ConfigureAwait(false)` in library/service code.
    -   Respect `CancellationToken`.

5.  **Logging**:
    -   Use `ILogger<T>` for services.
    -   Use `IAppLogger` for user-facing logs.
    -   **NEVER** use `Console.WriteLine`.

## Coding Style

-   **Naming**: PascalCase for public members, _camelCase for private fields.
-   **Formatting**: Allman style braces (new line). 4 spaces indentation.
-   **Namespaces**: Use file-scoped namespaces (`namespace MyNamespace;`).
-   **Nullability**: Assume `<Nullable>enable</Nullable>`. Check for nulls.

## AI Workflow (The 4 Stages)

When asked to implement a feature involving Mutagen or complex logic, you MUST follow this process:

1.  **Stage 1: API Selection**: List proposed APIs/Types. DO NOT generate implementation code yet.
2.  **Stage 2: Design Agreement**: Define Inputs, Outputs, Error Policy, and Dispose Plan.
3.  **Stage 3: Spike**: Provide minimal snippets to prove the concept.
4.  **Stage 4: Implementation**: Generate the full code only after approval.

## Common Errors to Avoid

-   Forgetting to dispose `GameEnvironment` or `LinkCache`.
-   Blocking the UI thread.
-   Hardcoding paths (use `IPathService`).
-   Using `ObservableCollection` from non-UI threads without dispatching.
