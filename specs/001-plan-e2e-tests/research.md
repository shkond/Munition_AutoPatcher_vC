# Phase 0 Research — E2E Test Implementation Plan

## Error classification for E2E validation
- **Decision**: Align with Constitution Section 9 by categorizing validation failures into Fatal vs Warning:
  - **Fatal**: 
    - ESP file missing after ViewModel execution
    - Mutagen overlay parse failure (corrupted ESP structure)
    - Structural count outside expected Range (indicates mapping logic regression)
  - **Warning**: 
    - Header timestamp mismatch (expected; normalized before diffing)
    - Small file size warning (< 1KB; allowed for minimal test scenarios)
    - Non-critical form link warnings from DiagnosticWriter
- **Rationale**: Fatal errors block CI (xUnit assertion fails); Warnings accumulate in `ValidationResult.Warnings` and are uploaded as artifacts but do not fail the test unless exceeding a scenario-specific threshold.
- **Alternatives considered**: (1) Fail on any warning — rejected to avoid flaky CI from benign header differences. (2) Ignore all warnings — rejected because it would mask real issues like missing DLC exclusions.

---

## Stage 1 — ProposedAPIs (Constitution Section 12 Compliance)

This section captures the **API selection review** required before implementing `EspFileValidator` and `TestServiceProvider`.

### EspFileValidator — Proposed APIs

| API | Namespace | Purpose | Error Policy |
|-----|-----------|---------|--------------|
| `Fallout4Mod.CreateFromBinaryOverlay(ModPath, GameRelease)` | `Mutagen.Bethesda.Fallout4` | Open ESP read-only for structural counts | Fatal if parse fails (corrupted) |
| `IFallout4ModDisposableGetter.Weapons`, `.Ammunitions`, `.ConstructibleObjects` | `Mutagen.Bethesda.Fallout4` | Count WEAP/AMMO/COBJ records | Warning if count = 0 on expected records |
| `ModHeaderFrame` / `MutagenBinaryReadStream` | `Mutagen.Bethesda.Plugins.Binary.Streams` | Read raw header for normalization | Fatal if header malformed |
| `Fallout4ModHeader.Timestamp`, `.NextFormID` | `Mutagen.Bethesda.Fallout4` | Fields to normalize before byte diff | N/A (normalization target) |

**MCP Reference**: Queried `Mutagen-Modding/Mutagen` via `mcp_mutagen-rag_search_repository`:
- `Fallout4Mod.cs` → `Fallout4ModBinaryOverlay` class provides overlay entry point
- `Fallout4ModHeader_Generated.cs` → `IFallout4ModHeaderGetter` with `Timestamp` property
- `StreamHeaderMixIn.cs` → `ReadModHeaderFrame` extension methods

### TestServiceProvider — Proposed APIs

| API | Namespace | Purpose | Error Policy |
|-----|-----------|---------|--------------|
| `ServiceCollection` / `IServiceProvider` | `Microsoft.Extensions.DependencyInjection` | Mirror App.xaml.cs DI graph | Fatal if resolution fails |
| `NullLoggerFactory.Instance` | `Microsoft.Extensions.Logging.Abstractions` | Default quiet logging | N/A |
| `IConfigService` (test stub) | `MunitionAutoPatcher.Services.Interfaces` | Pre-populated game/output paths | Fatal if paths invalid |
| `IPathService` (test stub) | `MunitionAutoPatcher.Services.Interfaces` | Temp root isolation | Fatal if directory creation fails |
| `IDiagnosticWriter` (test stub) | `MunitionAutoPatcher.Services.Interfaces` | Write under scenario folder | Warning if write fails |

**DisposePlan**:
- `TestEnvironmentBuilder` owns the `GameEnvironment` created per scenario
- `GameEnvironment` disposed via `await using` at xUnit test method boundary
- `LinkCache` disposed alongside `GameEnvironment`
- `EspFileValidator` uses overlay (no environment) — no disposal needed
- `TestServiceProvider.Build()` returns `IServiceProvider`; caller owns disposal of scoped services

### Rationale Summary
- **Overlay preference**: `CreateFromBinaryOverlay` avoids full deserialization overhead; used by production `IMutagenAccessor` pattern
- **Header normalization via low-level structs**: Avoids re-serializing entire mod; aligns with official Mutagen guidance
- **DI mirroring**: Ensures ViewModel receives exact production wiring per constitution Section 2/5

---

## ESP export + scenario persistence
- **Decision**: Extend the integration-test infrastructure with a helper that writes each `Fallout4Mod` generated by `TestEnvironmentBuilder` to a physical `.esp` using Mutagen's write builder (`BeginWrite...WriteAsync`) and, for smaller fixtures, the existing `WriteToBinary` helper already exercised inside [MunitionAutoPatcher/Services/Implementations/EspPatchService.cs](MunitionAutoPatcher/Services/Implementations/EspPatchService.cs#L70-L119).
- **Rationale**: Mutagen's official exporting guidance recommends the builder pipeline so we can feed load-order metadata (`WithDefaultLoadOrder`, `WithModKeySync`) and ensure master ordering, while legacy `WriteToBinary` remains viable for deterministic fixtures ([Mutagen "Exporting"](https://mutagen-modding.github.io/Mutagen/plugins/Exporting/#builder)). Reusing the same API surface as production guarantees we are validating the exact serialization behavior exercised by `IEspPatchService`.
- **AI verification required**: Before implementing `WriteToBinary` or `BeginWrite` calls, AI must use GitHub MCP (`mcp_mutagen-rag_search_repository`) to query the `Mutagen-Modding/Mutagen` repository for the exact signature of `Fallout4Mod.BeginWrite(...)` and confirm the required load-order parameters (Constitution Section 12, L201-205).
- **Alternatives considered**: (1) Copy raw bytes from the in-memory `MockFileSystem` used by `TestEnvironmentBuilder` directly into the temp game directory—rejected because it bypasses IMutagenAccessor guardrails and never validates exporting correctness. (2) Mock `IEspPatchService` output and assert on in-memory structures—rejected because the feature charter explicitly requires real ESP emission.

## Test DI surface for ViewModel harness
- **Decision**: Build a dedicated `TestServiceProvider` that mirrors the registrations in [MunitionAutoPatcher/App.xaml.cs](MunitionAutoPatcher/App.xaml.cs#L33-L167) but swaps certain services for test doubles: in-memory `IConfigService` (pre-populated game/output paths), `IPathService` targeting an isolated temp root, and `IDiagnosticWriter` writing under the scenario folder. Logging falls back to `NullLoggerFactory` to minimize noise.
- **Rationale**: Reusing the production registration order ensures the ViewModel receives the exact orchestration graph (IOrchestrator → providers/confirmers → IMutagenAccessor) mandated by the constitution, while overriding path/config services prevents the tests from touching real user artifacts. The existing App startup is the authoritative source for dependency graph, so mirroring it keeps future service additions from breaking tests silently.
- **Alternatives considered**: (1) Construct `MapperViewModel` manually with hand-built mocks—rejected because it would drift from the production DI graph and fail to exercise orchestrator wiring. (2) Spin up the entire `Host` from `App`—rejected to avoid WPF initialization side effects and because tests need deterministic path overrides that the default host would immediately persist to `config/config.json`.


**Logging in tests**:  
- テスト用`TestServiceProvider`は`NullLoggerFactory`を既定とするが、CI実行時やデバッグ時には`ILoggerFactory`をxUnit `ITestOutputHelper`へブリッジする`XunitLoggerProvider`に差し替え可能とする。
- `IDiagnosticWriter`はテストシナリオごとの成果物フォルダ配下（`scenario-{Id}/diagnostics/`）に出力し、本番LoggerProviderとは独立させる。
- Constitution Section 5の`ILogger<T>` / `IAppLogger`分離を尊重：テストハーネス内では`ILogger<ViewModelE2ETests>`等でログ記録し、`IAppLogger`はモック化してUI通知イベントのアサーション対象とする。

## Deterministic ESP validation + header normalization
- **Decision**: Validate artifacts in two passes: (a) structural counts via Mutagen overlays (open the ESP with `Fallout4Mod.CreateFromBinaryOverlay` to read COBJ/AMMO/WEAP counts exactly as production code does), and (b) byte-level comparison after normalizing the mod header fields that legitimately change between runs (timestamp, next form ID, author/description). Normalization will leverage Mutagen’s low-level header structs (`MutagenBinaryReadStream.ReadModHeaderFrame`) described in [Mutagen “Header Structs”](https://mutagen-modding.github.io/Mutagen/lowlevel/Header-Structs/).
- **Rationale**: Using overlays keeps the validator lightweight and enforces the same parsing rules as runtime services. Stripping volatile header bytes before diffing ensures nightly CI doesn’t fail due to differing timestamps while still flagging real record mutations. The official header-struct tooling is purpose-built for inspecting and rewriting header bytes without re-parsing the full mod.
- **Alternatives considered**: (1) Treat the ESP as an opaque blob and compare SHA-256 hashes—rejected because header timestamps would make hashes unstable. (2) Fully deserialize both mods with mutable constructors, zero properties, then serialize again—rejected due to unnecessary CPU cost and risk of mutating the artifact under validation.

## Dependency & integration best practices
- **Decision**: Keep Mutagen access behind `IMutagenAccessor` / `IMutagenEnvironmentFactory` even in tests. For E2E scenarios, `TestEnvironmentBuilder` creates a dedicated `GameEnvironment` per scenario run and owns it; the environment is wrapped in `await using` at the xUnit test method level to ensure deterministic disposal before artifact validation begins (Constitution Section 8.1).
- **LinkCache lifetime**: Each scenario receives a fresh `LinkCache` from the builder's environment; the cache is disposed alongside the environment. `EspFileValidator` opens ESPs via **overlay** (read-only, no GameEnvironment required) to avoid re-acquiring heavy resources post-generation (Constitution Section 2.3 — prefer WinningOverrides/overlays).
- **Performance**: Disposal of `GameEnvironment` must complete within 5 seconds to meet the 60-second validation target; if disposal is heavyweight (large plugin count), consider moving it to a background task while validation starts (Constitution Section 8.2 — avoid UI thread blocking, adapted here to test-thread blocking).
- **Rationale**: Section 2 of the constitution mandates the accessor boundary regardless of test code. Mirroring service lifetimes prevents concurrency issues (e.g., singleton `WeaponOmodExtractor`) and ensures cancellation tokens percolate correctly. Async xUnit facts already exist in [tests/IntegrationTests/WeaponDataExtractorIntegrationTests.cs](tests/IntegrationTests/WeaponDataExtractorIntegrationTests.cs), proving the pattern is stable.
- **Alternatives considered**: (1) Bypass IMutagenAccessor inside tests for convenience—rejected per constitution. (2) Share temp directories across tests to cut setup time—rejected because spec explicitly calls out isolation to avoid cross-contamination.
